<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Doc-as-Code: Metadata Format Specification | docfx website</title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Doc-as-Code: Metadata Format Specification | docfx website">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content">
        
        <div class="sidenav">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <a href="https://github.com/dotnet/docfx/blob/master/Documentation/spec/metadata_format_spec.md/#L1" class="btn btn-primary pull-right mobile-hide">Improve this Doc</a>
              <h1 id="doc-as-code-metadata-format-specification">Doc-as-Code: Metadata Format Specification</h1>
              
<h2 id="0-introduction">0. Introduction</h2>
<h3 id="0-1-goals-and-non-goals">0.1 Goals and Non-goals</h3>
<ol>
<li>The goal of this document is to define a general format to describe language metadata for programming languages.</li>
<li>The language metadata is designed to be language agnostic and support multiple programming language in a single metadata file.</li>
<li>The main user scenario for language metadata is to generate reference documentation, so this document will discuss how to optimize metadata format for documentation rendering.</li>
<li>This document does <strong>NOT</strong> discuss details of metadata format implementation of a specific programming language.</li>
</ol>
<h3 id="0-2-terminology">0.2 Terminology</h3>
<p>The key words <strong>MUST</strong>, <strong>MUST NOT</strong>, <strong>REQUIRED</strong>, <strong>SHALL</strong>, <strong>SHALL NOT</strong>, <strong>SHOULD</strong>, <strong>SHOULD NOT</strong>, <strong>RECOMMENDED</strong>,  <strong>MAY</strong>, and <strong>OPTIONAL</strong> in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.</p>
<p>Words in <em>italic</em> imply they are terms defined in an earlier section of this document.</p>
<h2 id="1-items-and-identifiers">1. Items and Identifiers</h2>
<h3 id="1-1-items">1.1 Items</h3>
<p>Item is the basic unit of metadata format. From documentation perspective, each item represents a &quot;section&quot; in the reference documentation. This &quot;section&quot; is the minimum unit that you can cross reference to, or customize its layout and content.</p>
<blockquote><p>When implementing the metadata format for your own language, you can decide which elements are items. For example, usually namespaces, classes, methods are items. But you can also make smaller elements like parameters to be item if you want them to be referencable and customizable.</p>
</blockquote>
<p>Items can be hierarchical. One item can have other items as children. For example, in C#, namespaces and classes can have classes and/or methods as children.</p>
<h3 id="1-2-identifiers">1.2 Identifiers</h3>
<p>Each <em>item</em> has an identifier (ID) which is unique under it&#39;s parent.</p>
<p>As we&#39;re targeting to support multiple languages, there is no  restrictions of which characters are not allowed in identifiers. But to make identifier easier to be recognized and resolved in markdown, it&#39;s not <strong>RECOMMENDED</strong> to have whitespaces in identifiers. Markdown processor <strong>MAY</strong> implement some algorithm to tolerate whitespaces in handwritten markdown. (Leading and trailing spaces <strong>MUST</strong> be removed from identifier.)</p>
<p>Identifier <strong>MUST</strong> be treated as case-sensitive when comparing equality.</p>
<p>Each <em>item</em> has a unique identifier (UID) which is globally unique. A UID is defined as follows:</p>
<ol>
<li>If an <em>item</em> does not have parent, its UID is its ID.</li>
<li>Otherwise its UID is the combination of the UID of its parent, a separator and the ID of the <em>item</em> itself.</li>
</ol>
<p>Valid separators are <code>.</code>, <code>:</code>, <code>/</code> and <code>\</code>.</p>
<p>For example, for a class <code>String</code> under namespace <code>System</code>, its ID is <code>String</code> and UID is <code>System.String</code>.</p>
<blockquote><p>Given the above definition, an <em>item</em>&#39;s UID <strong>MUST</strong> starts with the UID of its parent (and any of its ancestor) and ends with the ID of itself. This is useful to quickly determine whether an <em>item</em> is under another <em>item</em>.</p>
</blockquote>
<h3 id="1-3-alias">1.3 Alias</h3>
<p><em>Identifier</em> could be very long, which makes it difficult to write by hand in markdown. For example, it&#39;s easy to create a long <em>ID</em> in C# like this:</p>
<pre><code class="lang-markdown">Format(System.IFormatProvider,System.String,System.Object,System.Object)
</code></pre>
<p>We can create short alias for <em>items</em> so that they can be referenced easily.</p>
<p>Alias is same as <em>ID</em>, except:</p>
<ol>
<li>It doesn&#39;t have to be unique.</li>
<li>One <em>item</em> can have multiple aliases.</li>
</ol>
<blockquote><p>It&#39;s not <strong>RECOMMENDED</strong> to create alias that has nothing to do with item&#39;s <em>ID</em>. Usually an <em>item</em>&#39;s alias is part of its <em>ID</em> so it&#39;s easy to recognize and memorize.<br>For example, for the case above, we usually create an alias <code>Format()</code>.</p>
</blockquote>
<p>We can easily get a &quot;global&quot; alias for an <em>item</em> by replacing the <em>ID</em> part of its <em>UID</em> with its alias.</p>
<h2 id="2-file-structure">2. File Structure</h2>
<h3 id="2-1-file-format">2.1 File Format</h3>
<p>You can use any file format that can represent structural data to store metadata. But we recommend to use <a href="http://www.yaml.org/">YAML</a> or <a href="http://www.json.org/">JSON</a>. In this document, we use YAML in examples, but all YAML can be converted to JSON easily.</p>
<h3 id="2-2-file-layout">2.2 File Layout</h3>
<p>A metadata file consists of two parts, an &quot;item&quot; section and a &quot;reference&quot; section. Each section is a list of objects and each object is a key-value pair (hereafter referred to as &quot;property&quot;) list that represents an <em>item</em>.</p>
<h3 id="2-3-item-section">2.3 Item Section</h3>
<p>Though <em>items</em> can be hierarchical, they are flat in item section. Instead, each <em>item</em> has an &quot;children&quot; <em>property</em> indicates its children and a &quot;parent&quot; <em>property</em> indicates its parent.</p>
<p>An <em>item</em> object has some basic properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description                                      </th>
</tr>
</thead>
<tbody>
<tr>
<td>uid</td>
<td><strong>REQUIRED</strong>. The <em>unique identifier</em> of the <em>item</em>.</td>
</tr>
<tr>
<td>children</td>
<td><strong>OPTIONAL</strong>. A list of <em>UIDs</em> of the <em>item</em>&#39;s children. Can be omitted if there is no children.</td>
</tr>
<tr>
<td>parent</td>
<td><strong>OPTIONAL</strong>. The <em>UID</em> of the <em>item</em>&#39;s parent. If omitted, metadata parser will try to figure out its parent from the children information of other <em>items</em> within the same file.</td>
</tr>
</tbody>
</table>
<p>Here is an example of a YAML format metadata file for C# Object class:</p>
<pre><code class="lang-yaml">items:
- uid: System.Object
  parent: System
  children:
  - System.Object.Object()
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.Finalize()
  - System.Object.GetHashCode()
  - System.Object.GetType()
  - System.Object.MemberwiseClone()
  - System.Object.ReferenceEquals()
  - System.Object.ToString()
- uid: System.Object.Object()
  parent: System.Object
- uid: System.Object.Equals(System.Object)
  parent: System.Object
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
- uid: System.Object.Finalize()
  parent: System.Object
- uid: System.Object.GetHashCode()
  parent: System.Object
- uid: System.Object.GetType()
  parent: System.Object
- uid: System.Object.MemberwiseClone()
  parent: System.Object
- uid: System.Object.ReferenceEquals()
  parent: System.Object
- uid: System.Object.ToString()
  parent: System.Object
references:
...
</code></pre>
<blockquote><p><em>Items</em> <strong>SHOULD</strong> be organized based on how they will be displayed in documentation. For example, if you want all members of a class be displayed in a single page, put all members in a single metadata file.</p>
</blockquote>
<h3 id="2-3-item-object">2.3 Item Object</h3>
<p>In additional to the <em>properties</em> listed in last section, <em>item object</em> also has some <strong>OPTIONAL</strong> <em>properties</em>:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>The <em>identifier</em> of the <em>item</em>.</td>
</tr>
<tr>
<td>alias</td>
<td>A list of <em>aliases</em> of the <em>item</em>.</td>
</tr>
<tr>
<td>name</td>
<td>The display name of the <em>item</em>.</td>
</tr>
<tr>
<td>fullName</td>
<td>The full display name of the <em>item</em>. In programming languages, it&#39;s usually the full qualified name.</td>
</tr>
<tr>
<td>type</td>
<td>The type of the <em>item</em>, like class, method, etc.</td>
</tr>
<tr>
<td>url</td>
<td>If it&#39;s a relative url, it&#39;s another metadata file that defines the <em>item</em>. If it&#39;s an absolute url, it means the <em>item</em> is coming from an external library, and the url is the documentation page of this <em>item</em>. If omitted, the url is the location of the current file.</td>
</tr>
<tr>
<td>source</td>
<td>The source code information of the <em>item</em>. It&#39;s an object that contains following <em>properties</em>:<br>1. repo: the remote git repository of the source code.<br>2. branch: the branch of the source code.<br>3. revision: the git revision of the source code.<br>4. path: the path to the source code file where the <em>item</em> is defined.<br>5. startLine: the start line of the <em>item</em> definition.<br>6. endLine: the end line of the <em>item</em> definition.</td>
</tr>
</tbody>
</table>
<p>Here is an example of a C# Dictionary class:</p>
<pre><code class="lang-yaml">- uid: System.Collections.Generic.Dictionary`2
  id: Dictionary`2
  alias:
  - Dictionary
  parent: System.Collections.Generic
  name: Dictionary&lt;TKey, TValue&gt;
  fullName: System.Collections.Generic.Dictionary&lt;TKey, TValue&gt;
  type: class
  url: System.Collections.Generic.Dictionary`2.yml
  source:
    repo: https://github.com/dotnet/netfx.git
    branch: master
    revision: 5ed47001acfb284a301260271f7d36d2bb014432
    path: src/system/collections/generic/dictionary.cs
    startLine: 1
    endLine: 100
</code></pre>
<h3 id="2-4-custom-properties">2.4 Custom Properties</h3>
<p>Besides the predefined <em>properties</em>, <em>item</em> can have its own <em>properties</em>. One restriction is <em>property</em> name <strong>MUST NOT</strong> contains dots, as dot in <em>property</em> name will have special meaning (described in later section).</p>
<h3 id="2-5-reference-section">2.5 Reference Section</h3>
<p>Reference section also contains a list of <em>items</em>, these <em>items</em> serve as the references by <em>items</em> in <em>item section</em> and won&#39;t show up in documentation. Also reference <em>item</em> doesn&#39;t need to have full <em>properties</em>, it just contains necessary information needed by its referrer, for example, name or url.</p>
<p>In metadata file, all <em>items</em> <strong>MUST</strong> be referenced by <em>UID</em>.</p>
<blockquote><p>It&#39;s <strong>RECOMMENDED</strong> to include all referenced <em>items</em> in reference section. This makes the file self contained and easy to render at runtime.</p>
<p>Many programming languages has the concept of &quot;template instantiation&quot;. For example, in C#, you can create a new type <code>List&lt;int&gt;</code> from <code>List&lt;T&gt;</code> with argument <code>int</code>. You can create a reference for &quot;template instances&quot;. For example, for a class inherited from <code>List&lt;int&gt;</code>:</p>
</blockquote>
<pre><code class="lang-yaml">items:
- uid: NumberList
  inherits:
  - System.Collections.Generic.List&lt;System.Int32&gt;
references:
- uid: System.Collections.Generic.List`1&lt;System.Int32&gt;
  link: @{System.Collections.Generic.List`1}&lt;@{System.Int32}&gt;
- uid: System.Collections.Generic.List`1
  name: List
  url: system.collections.generic.list`1.yml
- uid: System.Int32
  name: int
  url: system.int32.yml
</code></pre>
<h3 id="2-6-multiple-language-support">2.6 Multiple Language Support</h3>
<p>There may be a need that an <em>item</em> supports multiple languages. For example, in .NET, a class can be used in C#, VB, managed C++ and F#. Different languages may have differences in <em>properties</em>. For example, a list of string is displayed as <code>List&lt;string&gt;</code> in C#, while <code>List(Of string)</code> in VB.</p>
<p>To support this scenario, we introduce a concept of language context to allow define different <em>property</em> values in different languages.</p>
<p>If a <em>property</em> name is in the form of <code>property_name.language_name</code>, it defines the value of <code>property_name</code> under <code>language_name</code>. For example:</p>
<pre><code class="lang-yaml">- uid: System.Collections.Generic.Dictionary`2
  name.csharp: Dictionary&lt;TKey, TValue&gt;
  name.vb: Dictionary(Of TKey, TValue)
</code></pre>
<p>This means the name of dictionary is <code>Dictionary&lt;TKey, TValue&gt;</code> in C# and <code>Dictionary(Of TKey, TValue)</code> in VB.</p>
<p>The following <em>properties</em> <strong>SHALL NOT</strong> be overridden in language context: uid, id, alias, children, parent.</p>
<h2 id="3-work-with-metadata-in-markdown-">3. Work with Metadata in Markdown </h2>
<h3 id="3-1-yaml-metadata-section">3.1 YAML Metadata Section</h3>
<p>In markdown file, you can also define <em>items</em> using the same metadata syntax. The metadata definition <strong>MUST</strong> be in YAML format and enclosed by triple-dash lines (<code>---</code>).
Here is an example:</p>
<pre><code class="lang-markdown">---
uid: System.String
summary: String class
---

This is a **string** class.
</code></pre>
<p>You can multiple YAML sections inside a single markdown file, but in a single YAML section, there <strong>MUST</strong> be only one <em>item</em>.</p>
<p>The YAML metadata section does not have to contain all <em>properties</em>. The only <em>property</em> that <strong>MUST</strong> appear is &quot;uid&quot;, which is used to match the same <em>item</em> in metadata file.</p>
<p>The most common scenario for using YAML section is to specify which <em>item</em> the markdown doc belongs to. But you can also override <em>item</em> <em>property</em> by defining one with the same name in YAML section. In the above example, the <em>property</em> &quot;summary&quot; will override the same one in metadata.</p>
<p>Same as language context, the following <em>properties</em> <strong>SHALL NOT</strong> be overridden: uid, id, alias, children, parent.</p>
<p>You <strong>SHALL NOT</strong> define new <em>item</em> in markdown.</p>
<h3 id="3-2-reference-items-in-markdown">3.2 Reference Items in Markdown</h3>
<p>We introduce a new markdown syntax to represent <em>item</em> reference:</p>
<p>If a string starts with <code>@</code>, and followed by a string enclosed by quotes <code>&#39;</code> or double quotes <code>&quot;</code>, it will be treated as an <em>item</em> reference. The string inside <code>&quot;&quot;</code> or <code>&#39;&#39;</code> is the <em>UID</em> of the <em>item</em>. Here is one example:</p>
<pre><code class="lang-markdown">@&quot;System.String&quot;
</code></pre>
<blockquote><p>Markdown processor <strong>MAY</strong> implement some algorithm to allow omit curly braces if <em>ID</em> is simple enough. For example, For reference like <code>@{int}</code>, we may also want to allow <code>@int</code>.</p>
</blockquote>
<p>When rendering reference in markdown, they will be expanded into a link with the <em>item</em>&#39;s name as link title. You can also customize the link title using the standard syntax of markdown:</p>
<pre><code class="lang-markdown">[Dictionary](@{System.Collections.Generic.Dictionary`2})&lt;[String](@{System.String}), [String](@{System.String})&gt;
</code></pre>
<p>Will be rendered to:
<code>[Dictionary](@{System.Collections.Generic.Dictionary`2})&lt;[String](@{System.String}), [String](@{System.String})&gt;</code></p>
<p>Besides <em>UID</em>, we also allow reference item using <em>ID</em> and <em>alias</em>, in markdown processor, the following algorithm <strong>SHOULD</strong> be implemented to resolve references:</p>
<ol>
<li>Check whether the reference matches any <em>identifier</em> of current <em>item</em>&#39;s children.</li>
<li>Check whether the reference matches any <em>alias</em> of current <em>item</em>&#39;s children.</li>
<li>Check whether the reference matches any <em>identifier</em> of current <em>item</em>&#39;s silbings.</li>
<li>Check whether the reference matches any <em>alias</em> of current <em>item</em>&#39;s silbings.</li>
<li>Check whether the reference matches a <em>UID</em>.</li>
<li>Check whether the reference matches a <em>global alias</em>.</li>
</ol>

            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
            <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
            </nav>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <span>Copyright © 2015 Microsoft<br>Powered by Doc-as-Code</span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>